inventario videogioco:
UI: inventario a schede
Prima versione {
   cure tiene un riferimento a ot per fermare timer / oppure cura = sempre ot, ma con timer nullo
   cura cambia stato di Player
   Player lancia segnale che è tornato normale, viene raccolto da ot che blocca il timer


   view ---- model --- container e iteratore ----- classe base ( gerarchia )

   model = Player* e container
   contenitore di item -> array allocato dinamicamente
   (
      Oppure
      rendere il model il Player e il gestore dei timer, ossia:
      model = hp, timer, contenitore
   )

   view -> emette segnale uso item -> raccolto da item -> SLOT(item::effect()) ->
   SLOT(item::effect()) -> emette segnale che lancia hp -> raccolto da Player

   effect() è praticamente un getter-emit di determinati parametri
   Cambiano paramentri e modi di richiamarlo a seconda della classe

   view seleziona item -> view invia item a model -> model ha funzione che:
   - fa le varie connect(player, item*)
   - cose rr 36-37:
      - view invia segnale con item* a modello
      - modello connette item a player
      - item e player si lanciano a vicenda i segnali e gli slot

   container: (array dinamico oppure lista)
   - insert (se lista, in cima)
   - remove (se lista bisogna solo cambiare next)
   - aggiunta metodo swap tra due inventari (inventario&, item*)
   - iteratore

   model:
      - Player
      - inventario
      - inventario equipped
      - insert into inventario
      - remove from inventario
      - equip item
      - selezione e attivazione oggetto inventario
}

cose da fare:

- capire come gestire l'unicità di oggetti multipli nell'inventario
   Proposal: item: u_int id, in inventario::insert(item* x) { assegnaID(); ...;}
- valutare idea implementazione potion:consumable (per cura veleno o tossicità)
- getSize() inventario -> funzionale a gestione ID degli item dell'inventario per l'unicità
- terminare ot se uso cura (pressoché fatto)
- collegare equipaggia per armi e scudi
- fare effettiva gui 
- collegare cambiamenti del player alla view (player manda segnali a model, model li rilancia a view. Quindi model avrà doppi segnali e slot)
- mettere immagini
- fare prompt per creazione oggetti (si può creare: arma, scudo, curaHP, cura status, veleno, tossicità)
- gestione salvataggio su file
- gestione upload file
- riposizionare in private player e inventario del model
- test su vm
- relazione


---------------------------------------------------------

            item (effect()=0)         |Inventario | Player | Model | View
      +---------+---------+           | lista di  |        | + inv |
 consumable             weapon        | item in   |        | + pl  |
      |                +-------+      | possesso  |        |       |
   overTime         shield   regular  |           |        |       |

item:                     // classe astratta in cima alla gerarchia
   - nome
   - path
   + string getName()
   + slot effect()=0

consumable: item
   - hpEffect            // può essere positivo o negativo a seconda di cosa sia
   + effect()
   + getEffect()
   + effectSignal(int)   // segnale

overTime: consumable     // oggetti a tempo (ogni tot chiamano effect)
   - timer               // ogni quanto tempo viene attivato l'effetto
   - status              // se attivo o meno (di default: no)
   - counter             // attivazioni massime (default: -1 -> infinite)
   + isActive
   + effect()              // modifica counter e ritorna il valore direttamente da Consumable::effect() -> hpEffect
   + stopOT()              // ferma l'effetto fermando il timer (emette segnale di stop)
   + startOT()             // attiva il timer
   + over()                // segnale di termine effetto

weapon: item
   - atk
   + effect()            // ritorna atk

regular: weapon
   - atk
   + effect()

shield: weapon
   - def                 // percentuale riduzione danni fisici
   + effect()

Player: 
   - hp
   - atk
   - def
   - status
   - path
   - pathCorrect()
   - pathCorrectness() const
   + getStatus() const
   + getStatusString() const
   + getHp() const
   + getDefense() const
   + getAttack() const
   + setDef()            // slot
   + setAtk()            // slot
   + changeHP()          // slot
   + changeStatus()      // slot
   + statusChanged()     // signal
   + hpChanged()         // signal

inventario:
   - nodo:
      + item* itm
      + nodo* next
   - nodo* first
   + iteratore:
      - nodo* ptr
      + operator..
   + begin() const
   + end() const
   + insertItm(item*)
   + removeItm(item*)

model: 
   - Player* pl
   - inventario inv
   + insert(item*)
   + remove(item*)
   + use(item*)
   + stopOverTime()  // slot
   + printStat()     // slot

View:
   - model*

---------------------------------------------