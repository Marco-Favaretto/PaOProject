inventario videogioco:
UI: inventario a schede

                item (effect()=0)
    +---------------+-------+----------/ /--------+
consumable                weapon =0            passive
   +-------+            +-------+---------+      (ring/armor)     
static     ot        strike   thrust   regular


                item (effect()=0)
    +-----------+---------+
 consumable =0?        weapon =0?
   +-------+           +-------+    
cure     ot       strike   regular


eliminazione static
overTime diventa specializzazione di consumable, che se overTime forza la chiamata effect() ogni timer

cure tiene un riferimento a ot per fermare timer / oppure cura = sempre ot, ma con timer nullo
cura cambia stato di Player
Player lancia segnale che Ã¨ tornato normale, viene raccolto da ot che blocca il timer


view ---- model --- container e iteratore ----- classe base ( gerarchia )

model = Player* e container
contenitore di item -> array allocato dinamicamente
(
   Oppure
   rendere il model il Player e il gestore dei timer, ossia:
   model = hp, timer, contenitore
)

view -> emette segnale uso item -> raccolto da item -> SLOT(item::effect()) ->
SLOT(item::effect()) -> emette segnale che lancia hp -> raccolto da Player

view seleziona item -> view invia item a model -> model ha funzione che:
- fa le varie connect(player, item*)
- cose rr 36-37:
   - view invia segnale con item* a modello
   - modello connette item a player
   - item e player si lancia a vicenda i segnali e gli slot

container: (array dinamico oppure lista)
- insert (se lista, in cima)
- remove (se lista bisogna solo cambiare next)
- iteratore

model:
   - Player
   - inventario
   - insert into inventario
   - remove from inventario
   - selezione e attivazione oggetto inventario