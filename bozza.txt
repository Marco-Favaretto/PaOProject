inventario videogioco:
UI: inventario a schede

                item (effect()=0)
    +---------------+-------+----------/ /--------+
consumable                weapon =0            passive
   +-------+            +-------+---------+      (ring/armor)     
static     ot        strike   thrust   regular


                item (effect()=0)
    +-----------+---------+
 consumable =0?        weapon =0?
   +-------+           +-------+    
(cure)     ot       shield   regular


eliminazione static
overTime diventa specializzazione di consumable, che se overTime forza la chiamata effect() ogni timer
overTime tiene variabile counter che emette segnale per terminare effetto dopo tot

cure tiene un riferimento a ot per fermare timer / oppure cura = sempre ot, ma con timer nullo
cura cambia stato di Player
Player lancia segnale che Ã¨ tornato normale, viene raccolto da ot che blocca il timer


view ---- model --- container e iteratore ----- classe base ( gerarchia )

model = Player* e container
contenitore di item -> array allocato dinamicamente
(
   Oppure
   rendere il model il Player e il gestore dei timer, ossia:
   model = hp, timer, contenitore
)

view -> emette segnale uso item -> raccolto da item -> SLOT(item::effect()) ->
SLOT(item::effect()) -> emette segnale che lancia hp -> raccolto da Player

view seleziona item -> view invia item a model -> model ha funzione che:
- fa le varie connect(player, item*)
- cose rr 36-37:
   - view invia segnale con item* a modello
   - modello connette item a player
   - item e player si lancia a vicenda i segnali e gli slot

container: (array dinamico oppure lista)
- insert (se lista, in cima)
- remove (se lista bisogna solo cambiare next)
- aggiunta metodo swap tra due inventari (inventario&, item*)
- iteratore

model:
   - Player
   - inventario
   - inventario equipped
   - insert into inventario
   - remove from inventario
   - equip item
   - selezione e attivazione oggetto inventario